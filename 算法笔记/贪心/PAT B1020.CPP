/*月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。
  现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以
  获得的最大收益是多少。
  
注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，
	  其库存量分别为18、15、10万吨，总售价分别为75、72、45亿元。如果市场的
	  最大需求量只有20万吨，那么我们最大收益策略应该是卖出全部15万吨第2种
	  月饼、以及5万吨第3种月饼，获得 72 + 45/2 = 94.5（亿元）。

输入格式：
	每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N表示月饼
	的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最大需求量。随后一
	行给出N个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出N个正数表示
	每种月饼的总售价（以亿元为单位）。数字间以空格分隔。

输出格式：
	对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后2位。

输入样例：
3 20
18 15 10
75 72 45
输出样例：
94.50
*/

/*思路
步骤1：采用“总是选择单价高的月饼出售，可以获得最大利润”的策略
	因此，对每种月饼都根据其库存量来计算该种月饼的单价
	此后，将月饼按单价从高到低排序 
步骤2：从单价高的月饼开始枚举
		1、如果库存不足以填充所有需求量，将该种月饼全部卖出，此时
		需求量减小该月饼库存量的大小，收益增加该种月饼的售价大小
		2、如果该种月饼的库存量足够供应需求量，只需提供需求量大小
		的月饼，此时受益增加当前需求量乘与该种月饼的单价，而需求
		减小为0 
这样子最后得到为所求的最大收益 
*/

#include<cstdio>
#include<algorithm> 
using namespace std;
struct mooncake{
	double store;//库存量
	double sell;//总售价
	double price;//单价 
}cake[1010];

bool cmp(mooncake a,mooncake b){//按单价从高到低排序 
	return a.price>b.price;
}

int main(){
	int n;//仓库数量 
	double D;//需求量 
	scanf("%d%lf",&n,&D);
	for(int i=0;i<n;i++){
		scanf("%lf",&cake[i].store);//每个仓库库存 
	}
	for(int i=0;i<n;i++){
		scanf("%lf",&cake[i].sell);//输入售价 
		cake[i].price=cake[i].sell/cake[i].store;//计算单价 
	}
	sort(cake,cake+n,cmp);//按单价从高到低排
	double ans=0;//收益
	for(int i=0;i<n;i++){
		if(cake[i].store<=D){//需求量高于库存 
			D-=cake[i].store;//第i种月饼全部卖出
			ans+=cake[i].sell;
		} else{//库存量高于需求量 
			ans+=cake[i].price*D;//只卖出需求的量的月饼
			break; 
		}
	}
	printf("%.2f\n",ans);
	return 0;
} 


