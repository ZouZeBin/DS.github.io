/*
2018上海交通大学上机题）
2017华中科技大学上机题）

假设国际象棋棋盘有5*5共25个格子。设计一个程序，使棋子从初始位置（左上角）开始跳马，
需要将棋盘的格子全部都走一遍，每个格子只允许走一次。

问：总共有多少解。（提示：回溯法）

P.S国际象棋的棋子是在格子中间的。国际象棋中的“马走日”，
如下图2所示，
	第一步为[1,1],
	第二步为[2,8]或[2,12]，
	第三步可以是[3,5]或[3,21]等，以此类推。
*/ 


/*
回溯法

1．概念

	回溯算法是类似于枚举的搜索尝试过程，
主要是在搜索尝试过程中寻找问题的解，当
发现已不满足求解条件时，就“回溯”返回，
尝试别的路径。

	回溯法是一种选优搜索法，按选优条件
向前搜索，以达到目标。但当探索到某一步
时，发现原先选择并不优或达不到目标，就
退回一步重新选择，这种走不通就退回再走
的技术称为回溯法，而满足回溯条件的某个
状态的点称为“回溯点”。

2．基本思想

   在包含问题的所有解的解空间树中，按
照深度优先搜索的策略，从根结点出发深 
度探索解空间树。当探索到某一结点时，要
先判断该结点是否包含问题的解，如果包含，
就从该结点出发继续探索下去，如果该结点
不包含问题的解，则逐层向其祖先结点回溯。
（其实回溯法就是对隐式图的深度优先搜索算法）。

	若用回溯法求问题的所有解时，要回溯到根，
且根结点的所有可行的子树都要已被搜索遍才结束。
若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

3.用回溯法解题的一般步骤：

（1）针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。

（2）确定结点的扩展搜索规则

（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

*/

/*4.算法框架

回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中 i 为搜索的深度。

int a[n];
try(int i)//函数
{
	if(i>n)
		输出结果；
	else
	{
		for(j=下界；j<=上界;j+=1)//枚举i所有可能的路径
		{
			if(fun(j))//满足限界函数和约束条件
			{
				a[i]=j;
				...//其他操作
				try(i+1);
				//回溯前的清理工作（如a[i]置空值等）; 
			} //if
		} //for
	} //else
} //try
*/
//回溯法求解马在棋盘中的走法问题
#include<stdio.h>
int steps = 0;//当前已走步数
int result = 0;//所有满足条件的解的数量
int axis_x[] = { 1,1,2,2,-1,-1,-2,-2 };//下一个可能位置在x轴上的移动方向
int axis_y[] = { 2,-2,1,-1,2,-2,1,-1 };//下一个可能位置在y轴上的移动方向
int grid[5][5] = {
	{0,0,0,0,0},
	{0,0,0,0,0},
	{0,0,0,0,0},
	{0,0,0,0,0},
	{0,0,0,0,0}
};//5X5棋盘，0表示还未经过此位置，1表示这个位置已经走过
int stepOrder[5][5] = {
	{0,0,0,0,0},
	{0,0,0,0,0},
	{0,0,0,0,0},
	{0,0,0,0,0},
	{0,0,0,0,0}
};//5X5棋盘，0表示还未经过此位置，其他数字代表第几步经过此位置
//判断一个位置是否满足条件
bool isAvailable(int x, int y) {
	//判断该位置是否超出范围
	if (x < 0 || x > 4 || y < 0 || y > 4)
		return false;
	//判断该位置是否已经走过
	if (grid[x][y] == 1)
		return false;
	return true;
}
//打印出步骤矩阵
void printStepOrder() {
	int i=0; 
	printf("第%d种情况\n", result);
	for (int m = 0; m < 5; m++) {
		for (int n = 0; n < 5; n++) {
			printf("%3d", stepOrder[m][n]);
			i+=stepOrder[m][n];
			
		}
		printf("\n");
	}

	printf("\n");
}



void findnext(int x, int y) {
	//找出下一个满足条件的位置
	for (int i = 0; i < 8; i++) {
		if (isAvailable(x + axis_x[i], y + axis_y[i])) {
			//当前位置满足条件，将其记入矩阵
			grid[x + axis_x[i]][y + axis_y[i]] = 1;//该位置已经走过 
			steps++;//记录步数 
			stepOrder[x + axis_x[i]][y + axis_y[i]] = steps;//记录在改点试探过的步数 
			//当棋盘全部走完后，打印出步骤
			if (steps == 25) {//因为每一步不能重复，走完25步即结束 
				result++;//解的个数加一 
				printStepOrder();//打印棋盘 
			}
			//当前位置满足条件，继续寻找下一个满足条件的位置
			findnext(x + axis_x[i], y + axis_y[i]);
			//当没有下一个满足条件的位置后，回溯
			steps--;
			grid[x + axis_x[i]][y + axis_y[i]] = 0;
		}
	}
}
int main() {
	steps = 1;
	grid[0][0] = 1;
	stepOrder[0][0] = 1;
	findnext(0, 0);
	getchar();
	return 0;
}

